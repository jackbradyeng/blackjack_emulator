Core Challenges

-- Object Ownership & Structure --

Do players "own" their hands? What if other players bet on their hand? What if the dealer needs to access the bet(s)
associated with their hand? What if the player elects not to bet on their hand or they bet on other players hands?
Can players use one another's empty positions?

The solution to these problems was to make Table the master object and populate it with Position objects. There are two
disjoint Position objects - Player Position and Dealer Position. Player Positions are what the players can actually bet
on and these contain Hands. The reason why Players do not directly store an instance of their Hand is because Hands can
be split (leading to the presence of multiple hands) and because other players can technically allowed to "back-bet" on
their hand. For these reasons, it made sense to use the Table-Position model as opposed to the Player-Hand model.

-- Dealing with the Ace Card --

---- The Identification Problem ----
One of the more trivial (yet still important) problems was differentiating the Ace card from the others. This is
important because detecting an Ace is required for facilitating certain game functions - like telling the game when
the player can buy insurance for example. The solution was to make Ace a child class of card. This circumvented the
need for flags, and could be used in other methods with Java's instanceof keyword.

---- The Hand Value Problem ----
One of the core operations in Blackjack is calculating the value of a hand. For most cards, this is fairly simple. Twos
through to tens are valued as themselves, while the face cards - Jacks, Queens, and Kings - are valued as tens. The Ace
on the other hand is more complicated. In Blackjack, Aces can have two values - 1 and 11. When the hand value (excluding
the ace) is less than or equal to 10, the Ace can be counted as either 1 or 11. But when the hand value is greater than
10, the Ace must be counted as 1. Furthermore, when there are multiple Aces in a hand, the hand value logic must allow
some to be valued as 1 and others as 11.

Note that the Deck class includes a hashmap which maps each of the cards to their corresponding values. By definition,
this is a one-to-one mapping. For each of the four Ace cards, the hashmap stores the upper value as the default value.
To overcome the problem of Aces having two (sometimes alternating) values, the calculateHandValue() method in the Hand
class performs two sweeps. First, it loops through the hand calculating the value of all non-Ace cards. Next, it loops
through the hand again, evaluating each of the Ace cards (if any). If one Ace card has already been detected, the rest
are valued as 1. The basic goal is to maximized the hand value without making the hand go bust.

-- Dealer vs. Player Functions --

---- Dealer Position vs. Player Position ----
---- Dealer Hand vs. Player Hand ----

-- Logging Bets --

A special type of data structure was required for logging the bets on each position. This is because Blackjack allows
players to buy insurance on multiple positions, meaning that if we were to log player bets on each hand in a HashMap,
the keys in the map will not be unique. Since the Map.Entry interface does not enforce key-value uniqueness I chose to
compose it in an ArrayList of entries which logs all the bets on a particular position. This data structure is similar
to a Multimap, but naturally it foregoes the constant lookup time of a HashMap.

    /* -- deprecated data structures --
     * These don't work because all implementations of the Map interface in Java enforce key uniqueness. Player's can
     * theoretically have multiple bets on a position by doubling down and buying insurance so these data structures
     * can't be used in the PlayerHand class.
     *
     * private TreeMap<Player, Bet> pairs;
     * private HashMap<Player, Bet> pairs; */

---- Acting Player vs. Default Player ----

---- Standard Bets vs. Insurance Bets vs. Double Bets ----

-- The Shuffling Algorithm --

The vast majority of casinos use multiple decks at their Blackjack tables. The minimum is usually four with many using
upwards of eight or twelve in rotation at any given time. These are placed inside a "shoe" (container for the decks)
which is then cut by the dealer. The goal is randomisation and countermeasures against counting cards (maintaining
a head count of the number of face cards which have been dealt relative to the total copies in the shoe).

For this program, I went with Fisher-Yates since it's simple, easy to implement, and maximizes the "randomness" of an
ordered sequence of objects. This was done using Java's random library which features an RNG in the form of the
random.nextInt() method. According to the Java documentation for this method, it uses system time as the seed for the
randomly generated number. Since the algorithm executes extremely fast, I'm worried this might not be creating entropy
needed for a truly random order - the whole deck is shuffled at the start of the round as part of the draw routine. I
think this requires further investigation...

-- Hand Splitting & Active Hand Iteration --

The main problem with the implementing the hand splitting mechanic was handling ConcurrentModificationExceptions. The
runGameLoop() method in the Controller class as well as the executePlayerStrategyForAll() method in the Table class both
rely on an ActiveHands instance which is configured as an ArrayList. Iterating over this object using a for-each loop
would (my initial approach) throws a ConcurrentModificationException:

    for(PlayerHand hand : table.getActiveHands()) {
        // split hand
    }

This is because for-each loops - otherwise known as "enhanced" for loops - have fail-fast behaviour in Java. As soon as
the JVM detects that the size of the array has changed, then during iteration, the program will throw an exception. I
circumvented this by using a standard iterative for loop instead:

    for(int i = 0; i < table.getActiveHands().size()) {
        // split hand
    }

This allowed for the the size and composition of the ActiveHands list to be modified during iteration. Thus, when the
player elected to split their hand, the game state would progress as normal.